# MoneyPow---(ershell) , Copyright 2022 669ceb2540d15cae2c6d3295e09efaa53e00ec374dd631333b684eade01a5b74

# Clear host before starting game.
Clear-Host
#Information & How to play
Write-Host "
PLEASE READ
MoneyPow is a basic implementation of 'crash', a popular gambling game where
a number is generated on a curve, weighted toward 1, this number is then used as a multiplier
for a users bet. I tested the formula used here by generating 1,000,000 points in python to verify a high degree of accuracy relative to the industry
(as I'm using a non standard method of calculation) and it was, as shown by this histogram (source code provided here too) of those 1x10^6 points:
https://imgur.com/a/cgHGiCo
Normally the crash point (also called Multiplier in this project) is generated by linking hashes, and using the parsed hash to create the crash point... anyway,
in this case I don't use this as it's beyond the scope of this project. I will use a derived formula, shown here https://youtu.be/F1HA7e3acSI at 00:03:10
To play the game you will input an amount to bet, then you will be asked for the 'multiplier.' The multiplier you give, must be below the crash point in order to win.
For example, if you set your multiplier to 3, then the generated crash point is 4, you will receive 3x your bet (calculated, per standard, as: balance-bet+bet*multiplier), and if the
crash point were 2, then you would have received nothing, and lost your entire bet because the generated point was below your 'expected' point.
So the fun is making the call as to what crash point is better for your current balance, and bet size, in order to make money! (Of course, the house always wins! (discussed further in the linked video)).
By default everyone starts with `$1500.
Have fun!
"
# Declare global session variables.
$balance = 1500
# The main game function!
function play {
    # If you try and play with no balance
    if ($balance -eq 0) {
        Write-Host "
        `n
        You're out of money, take a loan (y/n)? Just kidding, we know you're not good for it. Restart if you want to try again
        `n
        The process of restarting is hard and annoying to discourage unaware gambling
        `n
        "
        $confirmation = Read-Host "Press Enter key to continue"
        # Hacky logic to get confirmation dialog
        if ($confirmation -ne 0) {
            exit
        }
    }   
    $userBet = Read-Host "How much would you like to bet"
    if ($userBet -match '[0-9]+$') {
        if ([float]$userBet -gt $balance -or [float]$userBet -lt 0) {
            Write-Host "Insufficient balance, you have `$$balance, try again"
            play
        } 
    }
    else {
        Write-Host "Please input a number!"
        play
    }
    function getUserMultiplier {
        $global:userMultiplier = Read-Host "When do you want to cashout"
        if($userMultiplier -le 1 -or $userMultiplier -notMatch '[0-8]') {
            Write-Host "Please input a *number* greater than 1 as you multiplier"
            getUserMultiplier
        }
    }
    getUserMultiplier
    createAndApplyCrashPoint($userBet, $userMultiplier)
}
# I made a function for the user dialog, so I can call it whenever and use it for more than one part of the game.
function userDialog {
    $userSay = Read-Host "You now have `$$balance, play again? (y/n)"
    if ($userSay -eq "y") {
        # Restart the game
        play
    }
    elseif ($userSay -eq "n") {
        # self explanatory
        exit
    }
    else {
        Write-Host "That didn't work, please type 'y' for yes or 'n' for no"
        # Restart dialog if the user is incapable of using a keyboard
        userDialog
    }
}
# Function for pretty much everything else.
function createAndApplyCrashPoint {
    # For our equation, we need a number between 0 and 1, but Get-Random can't handle a non-integer, highly precise number, so I've made this workaround.
    # For the purposes of this project, this will produce a range that's close enough to the industry. (within a couple tenths of percent)
    [int64]$random = Get-Random -Minimum 1 -Maximum 99999999999999999
    # Converting the random number to a number between 0, 1 for our equation.
    [float]$uniform = $random / 100000000000000000
    # The industry standard multiplier equation can be siplified into 0.01 + (0.99/Uniform(0,1)) as
    # Shown by this video: https://youtu.be/F1HA7e3acSI around minute 3. There is also a good explanation of how the crash point is usually generated, in the minutes before

    # MoneyPow---(ershell) doesn't follow the regular method of multiplier generation, only a derivation of the usual function.
    # A real crash gambling site would use hashes to create each point, where each hash is created from the hash before it, allowing
    # provable 'fairness' (i.e. You know how much money they're going to take from you)
    # Calculating the multiplier
    $multiplier = 0.01 + (0.99 / $uniform)

    # Give ~3% chance of instant failure.
    if (($random % 33) -eq 0) {
        #subtract bet from balance.
        $balance = $balance - $userBet
        Write-Host "Bad Luck, try again, the Multiplier was 1.00"
        # Call user dialog function.
        userDialog
    }
    # If the multiplier isn't zero
    else {
        # Check if the multiplier is greater than the selected multiplier.
        if ($multiplier -gt $userMultiplier) {
            # Mark this game as a win
            $wonorlost = "won"
            # Calculate the new balance (parse input to a number otherwise it concats lol)
            $balance = $balance - $userBet + ([float]$userBet * $userMultiplier)
        }
        else {
            # Mark this game as a loss
            $wonorlost = "lost"
            # Calculate the new balance.
            $balance = $balance - $userBet
        }
        Write-Host "The crash point was $multiplier, and you selected $userMultiplier as your multiplier, so you $wonorlost!"
        # call the dialog
        userDialog

    }

}
# Start the game
play
